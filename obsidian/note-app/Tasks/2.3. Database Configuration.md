# Database Configuration

## Prerequisites
- SQLAlchemy installed (verified in requirements.txt)
- Python-dotenv installed
- Project structure set up

## Steps

### 1. Create Database Configuration File
- [x] Create `backend/app/database.py` with the following content:
  ```python
  from sqlalchemy import create_engine
  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy.orm import sessionmaker
  from dotenv import load_dotenv
  import os

  # Load environment variables
  load_dotenv()

  # Database URL (default to SQLite for development)
  SQLALCHEMY_DATABASE_URL = os.getenv(
      "DATABASE_URL",
      "sqlite:///./notes.db"
  )

  # Create SQLAlchemy engine
  engine = create_engine(
      SQLALCHEMY_DATABASE_URL,
      connect_args={"check_same_thread": False}  # SQLite specific
  )

  # Create SessionLocal class
  SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

  # Create Base class
  Base = declarative_base()

  # Dependency for database sessions
  def get_db():
      db = SessionLocal()
      try:
          yield db
      finally:
          db.close()
  ```

### 2. Create Environment File
- [x] Create `backend/.env` file:
  ```plaintext
  DATABASE_URL=sqlite:///./notes.db
  ```

### 3. Update .gitignore
- [x] Add database-related entries to `.gitignore`:
  ```plaintext
  # Database
  *.db
  *.sqlite
  ```

### 4. Integration Steps
- [x] Import database components in `main.py`:
  ```python
  from .database import engine, Base
  
  # Create database tables
  Base.metadata.create_all(bind=engine)
  ```

### 5. Verification Checklist
- [x] Verify SQLAlchemy installation
- [x] Confirm database file creation
- [x] Test database connection
- [x] Ensure environment variables are loaded

## Notes
- SQLite is used for development for its simplicity
- The configuration supports future migration to PostgreSQL
- Database sessions are handled automatically
- Connection pooling is managed by SQLAlchemy

## Next Steps
After completing this setup, proceed to:
- Define database models
- Create schemas
- Implement CRUD operations